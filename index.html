<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Vibe Universe</title>
		<link rel="stylesheet" href="./controls.css" />
		<script type="text/javascript" src="./lib/paper-full.js"></script>
		<script type="text/javascript" src="./lib/svg-export.js"></script>
		<style>
			body {
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				height: 100vh;
				margin: 0;
				background-color: #161616;
				overflow: hidden;
			}
			canvas {
				cursor: grab;
				max-width: 100vw;
				max-height: 100vh;
			}
			canvas:active {
				cursor: grabbing;
			}
		</style>
	</head>
	<body>
		<div id="menuToggleWrapper">
			<div id="menuToggle">
				<span></span>
			</div>
		</div>

		<div class="controls">
			<h3 style="margin-top: 0; margin-bottom: 15px">Solar System Controls</h3>

			<div class="control-group">
				<table style="width: 100%; font-size: 12px">
					<tr>
						<td>Time Scale:</td>
						<td style="text-align: right">
							<span id="timeSpeedValue">1.1M×</span>
						</td>
					</tr>
					<tr>
						<td>Inclination:</td>
						<td style="text-align: right">
							<span id="inclinationValue">60°</span>
						</td>
					</tr>
					<tr>
						<td>Rotation:</td>
						<td style="text-align: right">
							<span id="rotationValue">0°</span>
						</td>
					</tr>
					<tr>
						<td>Zoom:</td>
						<td style="text-align: right">
							<span id="scaleValue">1.00x</span>
						</td>
					</tr>
				</table>
			</div>

			<div class="control-group">
				<label>
					<input type="checkbox" id="showOrbits" checked />
					Show Orbits
				</label>
			</div>

			<div class="control-group">
				<label>
					<input type="checkbox" id="showLabels" checked />
					Show Labels
				</label>
			</div>

			<div class="control-group">
				<label>
					<input type="checkbox" id="showCompoundNames" />
					Show Compound Names
				</label>
			</div>

			<div class="control-group">
				<label>
					Label Font Size:
					<span id="fontSizeValue" class="value">12px</span>
				</label>
				<input
					type="range"
					id="fontSizeSlider"
					min="10"
					max="24"
					value="12"
					step="1"
				/>
			</div>

			<button id="pausePlay">Pause</button>

			<div
				class="control-group"
				style="margin-top: 20px; border-top: 1px solid #555; padding-top: 15px"
			>
				<label style="font-size: 11px; margin-bottom: 10px">Examples:</label>
				<div style="display: flex; flex-direction: column; gap: 5px">
					<a
						href="view-formula-colors.html"
						style="color: #4a90e2; text-decoration: none; font-size: 11px"
						>Formula Colors</a
					>
					<a
						href="example-planet-composition.html"
						style="color: #4a90e2; text-decoration: none; font-size: 11px"
						>Planet Composition</a
					>
				</div>
			</div>

			<div
				class="control-group"
				style="margin-top: 15px; border-top: 1px solid #555; padding-top: 15px"
			>
				<a
					href="https://github.com/select/vibe-universe"
					target="_blank"
					rel="noopener noreferrer"
					style="
						color: #4a90e2;
						text-decoration: none;
						font-size: 11px;
						display: flex;
						align-items: center;
						gap: 5px;
					"
				>
					<span style="font-size: 14px">⚙</span> GitHub Repository
				</a>
			</div>
		</div>

		<div class="info">Press 'd' to export as SVG</div>

		<div class="scale-indicator">
			<div class="scale-item">
				<div class="scale-label">Orbital Distance</div>
				<div id="orbitScaleText">100 million km</div>
				<div class="scale-line"></div>
			</div>
			<div class="scale-item">
				<div class="scale-label">Planet/Moon Size</div>
				<div id="planetScaleText">255 thousand km</div>
				<div class="scale-line"></div>
			</div>
		</div>

		<canvas id="myCanvas" width="1200" height="1200"></canvas>

		<script type="module">
			import { celestialBodyCompositions } from "./planet-composition.js";
			import { getFormulaColor } from "./formula-registry.js";
			import { formatFormulaWithSubscripts } from "./lib/formula-utils.js";
			import { planetsData, sunData } from "./planets-data.js";
			import { Controls } from "./controls.js";

			paper.setup(document.getElementById("myCanvas"));
			const center = paper.view.center;

			// Simulation state - using object for shared state with Controls
			const simulationState = {
				timeSpeed: 1.0,
				inclination: 60, // degrees (-90 to 90)
				rotation: 0, // degrees (0 to 360) - view angle rotation around Y axis
				scale: 1.0,
				showOrbits: true,
				showLabels: true,
				showCompoundNames: false, // Show compound names instead of formulas in composition diagram
				isPaused: false,
				labelFontSize: 12, // Default font size for planet labels
				viewMode: "solar-system", // 'solar-system' or 'planet-moons'
			};

			let time = 0;
			const minOrbitRadiusForLabel = 70; // Minimum orbit radius (in pixels) to show labels and enable interactions

			// Planet selection state
			let selectedPlanet = null;
			let fadeOpacity = 1.0;
			let planetOffset = new paper.Point(0, 0);
			let transitionProgress = 0; // 0 = solar system, 1 = moon view
			let selectedPlanetPosition = null; // Store planet's position during transition

			// Groups for organized rendering
			let axisGroup = new paper.Group();
			let orbitGroup = new paper.Group();
			let planetGroup = new paper.Group();
			let labelGroup = new paper.Group();
			let moonGroup = new paper.Group();
			let clickAreaGroup = new paper.Group();

			// Convert 3D orbital position to 2D screen coordinates
			function project3DTo2D(x, y, z, inclination, rotation = 0) {
				// First apply rotation around Y axis
				const rotRad = (rotation * Math.PI) / 180;
				const xRot = x * Math.cos(rotRad) + z * Math.sin(rotRad);
				const zRot = -x * Math.sin(rotRad) + z * Math.cos(rotRad);

				// Then apply inclination (rotation around X axis)
				const incRad = (inclination * Math.PI) / 180;
				const screenX = xRot;
				const screenY = y * Math.cos(incRad) - zRot * Math.sin(incRad);
				return new paper.Point(screenX, screenY);
			}

			// Draw XYZ axis lines from the sun
			function drawAxisLines() {
				axisGroup.removeChildren();

				// Skip axis lines in moon view mode
				if (simulationState.viewMode === "planet-moons") return;

				const axisLength = 50 * simulationState.scale; // Length of axis lines (even smaller)

				// X-axis (Red) - extends along the X direction
				const xEnd3D = { x: axisLength, y: 0, z: 0 };
				const xEndPos = project3DTo2D(
					xEnd3D.x,
					xEnd3D.y,
					xEnd3D.z,
					simulationState.inclination,
					simulationState.rotation,
				);
				const xLine = new paper.Path.Line(center, center.add(xEndPos));
				xLine.strokeColor = "#FF4444"; // Red
				xLine.strokeWidth = 1; // Thinner
				xLine.opacity = 0.7;
				axisGroup.addChild(xLine);

				// Y-axis (Green) - extends along the Z direction
				const yEnd3D = { x: 0, y: 0, z: axisLength };
				const yEndPos = project3DTo2D(
					yEnd3D.x,
					yEnd3D.y,
					yEnd3D.z,
					simulationState.inclination,
					simulationState.rotation,
				);
				const yLine = new paper.Path.Line(center, center.add(yEndPos));
				yLine.strokeColor = "#44FF44"; // Green
				yLine.strokeWidth = 1; // Thinner
				yLine.opacity = 0.7;
				axisGroup.addChild(yLine);

				// Z-axis (Blue) - extends along the Y direction (up)
				const zEnd3D = { x: 0, y: axisLength, z: 0 };
				const zEndPos = project3DTo2D(
					zEnd3D.x,
					zEnd3D.y,
					zEnd3D.z,
					simulationState.inclination,
					simulationState.rotation,
				);
				const zLine = new paper.Path.Line(center, center.add(zEndPos));
				zLine.strokeColor = "#4444FF"; // Blue
				zLine.strokeWidth = 1; // Thinner
				zLine.opacity = 0.7;
				axisGroup.addChild(zLine);

				// X label (Red) - positioned 5px beyond the tip
				const xLabelOffset = xEndPos.normalize(xEndPos.length + 5);
				const xLabel = new paper.PointText(center.add(xLabelOffset));
				xLabel.content = "X";
				xLabel.fillColor = "#FF4444";
				xLabel.fontSize = simulationState.labelFontSize * 0.7;
				xLabel.fontFamily = "monospace";
				xLabel.fontWeight = "bold";
				xLabel.justification = "center";
				xLabel.opacity = 0.7;
				axisGroup.addChild(xLabel);

				// Y label (Green) - positioned 5px beyond the tip
				const yLabelOffset = yEndPos.normalize(yEndPos.length + 5);
				const yLabel = new paper.PointText(center.add(yLabelOffset));
				yLabel.content = "Y";
				yLabel.fillColor = "#44FF44";
				yLabel.fontSize = simulationState.labelFontSize * 0.7;
				yLabel.fontFamily = "monospace";
				yLabel.fontWeight = "bold";
				yLabel.justification = "center";
				yLabel.opacity = 0.7;
				axisGroup.addChild(yLabel);

				// Z label (Blue) - positioned 5px beyond the tip
				const zLabelOffset = zEndPos.normalize(zEndPos.length + 5);
				const zLabel = new paper.PointText(center.add(zLabelOffset));
				zLabel.content = "Z";
				zLabel.fillColor = "#4444FF";
				zLabel.fontSize = simulationState.labelFontSize * 0.7;
				zLabel.fontFamily = "monospace";
				zLabel.fontWeight = "bold";
				zLabel.justification = "center";
				zLabel.opacity = 0.7;
				axisGroup.addChild(zLabel);
			}

			// Draw orbits
			function drawOrbits() {
				orbitGroup.removeChildren();

				if (!simulationState.showOrbits) return;

				// Skip planet orbits in moon view mode
				if (simulationState.viewMode === "planet-moons") return;

				planetsData.forEach((planet) => {
					// Skip non-selected planet orbits when fading
					if (
						selectedPlanet &&
						selectedPlanet !== planet &&
						fadeOpacity < 1.0
					) {
						return;
					}

					// Draw planet orbit using unified function
					drawOrbitPath({
						centerPosition: center,
						distance: planet.distance,
						scale: simulationState.scale,
						color: planet.color,
						orbitalInclination: planet.orbitalInclination,
						inclination: simulationState.inclination,
						time: time,
						period: planet.period,
						angle: planet.angle,
						transitionProgress:
							selectedPlanet === planet ? transitionProgress : 0,
						segments: 100,
						strokeWidth: 1,
						alpha: 0.2,
						group: orbitGroup,
					});
				});
			}

			// Draw the sun
			function drawSun() {
				const minSunSize = 3;
				const scaledSunSize = Math.max(
					sunData.size * simulationState.scale,
					minSunSize,
				);
				const sun = new paper.Path.Circle(center, scaledSunSize);
				sun.fillColor = sunData.color;
				sun.strokeColor = sunData.strokeColor;
				sun.strokeWidth = 2;
				return sun;
			}

			// Draw label with angled connector line for celestial body
			function drawLabel(config) {
				const {
					position, // paper.Point - center position of body
					startRadius, // number - radius where label line starts (click circle radius)
					name, // string - label text
					labelSuffix = "", // string - optional suffix (e.g., "(-10x)")
					bodyType, // string - "planet" or "moon"
					opacity = 1, // number - opacity
					targetGroup, // paper.Group - group to add label to (labelGroup or moonGroup)
					currentLayer = null, // string - current layer being displayed (e.g., "surface")
				} = config;

				// Line segment lengths (smaller for moons)
				const segment1Length = bodyType === "planet" ? 10 : 5;
				const segment2Length = bodyType === "planet" ? 15 : 10;
				const angle60 = (-60 * Math.PI) / 180;

				// Start at click circle border on the lower-right
				const startPoint = position.add(
					new paper.Point(
						Math.cos(angle60) * startRadius,
						Math.sin(angle60) * startRadius,
					),
				);

				// First segment: angled at -60°
				const segment1End = startPoint.add(
					new paper.Point(
						Math.cos(angle60) * segment1Length,
						Math.sin(angle60) * segment1Length,
					),
				);

				// Second segment: horizontal to the right
				const segment2End = segment1End.add(new paper.Point(segment2Length, 0));

				// Draw the connector line
				const connectorLine = new paper.Path();
				connectorLine.strokeColor = new paper.Color(0.6, 0.6, 0.6);
				connectorLine.strokeWidth = bodyType === "planet" ? 0.5 : 0.3;
				connectorLine.opacity = opacity;
				connectorLine.add(startPoint);
				connectorLine.add(segment1End);
				connectorLine.add(segment2End);
				targetGroup.addChild(connectorLine);

				// Draw the label text
				const labelOffset =
					bodyType === "planet" ? new paper.Point(5, 3) : new paper.Point(3, 2);
				const label = new paper.PointText(segment2End.add(labelOffset));
				label.content = name + labelSuffix;
				label.fillColor = "white";
				label.fontSize =
					bodyType === "planet"
						? simulationState.labelFontSize
						: simulationState.labelFontSize * 0.8;
				label.fontFamily = "monospace";
				label.justification = "left";
				label.opacity = opacity;
				targetGroup.addChild(label);

				// Add moon count indicator for planets (if they have moons)
				if (bodyType === "planet") {
					// Find planet data to get moon count from planetsData array
					const planetData = planetsData.find((p) => p.name === name);
					const moonCount = planetData?.moons?.length || 0;

					if (moonCount > 0) {
						// Calculate position: 2 spaces after the planet name
						const labelBounds = label.bounds;
						const moonLabelPos = new paper.Point(
							labelBounds.right + 10,
							segment2End.add(labelOffset).y,
						);

						const moonLabel = new paper.PointText(moonLabelPos);
						moonLabel.content = moonCount + " ⏾";
						moonLabel.fillColor = new paper.Color(0.5, 0.5, 0.5); // Gray color
						moonLabel.fontSize = simulationState.labelFontSize * 0.8;
						moonLabel.fontFamily = "monospace";
						moonLabel.justification = "left";
						moonLabel.opacity = opacity;
						targetGroup.addChild(moonLabel);
					}
				}

				// Draw layer indicator symbol next to name if layer is specified and data is available
				if (currentLayer && ["planet", "moon"].includes(bodyType)) {
					// Check if composition data exists for this body
					const hasCompositionData = celestialBodyCompositions.find(
						(cb) => cb.name === name,
					);

					if (hasCompositionData) {
						// Map layer names to symbols: ⬤⨀⦾⦿⚬
						const layerSymbols = {
							surface: "⬤",
							mantle: "⨀",
							intermediate: "⦾",
							core: "⦿",
							default: "⚬",
						};

						const symbol = layerSymbols[currentLayer] || layerSymbols.default;

						// Position below and slightly right of the label text
						const layerOffset = new paper.Point(
							10,
							simulationState.labelFontSize + 5,
						);
						const layerPos = segment2End.add(labelOffset).add(layerOffset);

						// Draw symbol and layer name combined
						const layerText = new paper.PointText(layerPos);
						const layerName =
							currentLayer.charAt(0).toUpperCase() + currentLayer.slice(1);
						layerText.content = symbol + " " + layerName;
						layerText.fillColor = "#999999";
						layerText.fontSize = simulationState.labelFontSize * 0.8;
						layerText.fontFamily = "monospace";
						layerText.justification = "left";
						layerText.opacity = opacity;
						targetGroup.addChild(layerText);
					}
				}
			}

			// Helper function to calculate orbital position
			function calculateOrbitalPosition(config) {
				const {
					time, // number - current time
					period, // number - orbital period
					angle, // number - starting angle offset
					distance, // number - orbital distance
					scale, // number - scaling factor
					orbitalInclination, // number - orbital inclination in degrees
					inclination, // number - view inclination in degrees
				} = config;

				// Calculate orbital angle based on time and period
				const currentAngle = angle + (time / period) * Math.PI * 2;

				// Calculate 3D position (apply simulationState.scale)
				const scaledDistance = distance * simulationState.scale;
				const x = Math.cos(currentAngle) * scaledDistance;
				const z = Math.sin(currentAngle) * scaledDistance;

				// Apply orbital simulationState.inclination (rotate around x-axis)
				const incRad = (orbitalInclination * Math.PI) / 180;
				const y = z * Math.sin(incRad);
				const zInclined = z * Math.cos(incRad);

				// Project to 2D
				const screenPos = project3DTo2D(
					x,
					y,
					zInclined,
					simulationState.inclination,
					simulationState.rotation,
				);

				return {
					screenPos: screenPos, // paper.Point - 2D projected position
					angle: currentAngle, // number - current orbital angle
					scaledDistance: scaledDistance, // number - scaled distance
				};
			}

			// Helper function to draw an orbit path
			function drawOrbitPath(config) {
				const {
					centerPosition, // paper.Point - center of the orbit
					distance, // number - orbit radius in original units
					scale, // number - scaling factor
					color, // string - orbit color
					orbitalInclination, // number - inclination in degrees
					inclination, // number - view inclination
					time, // number - current time (for planet orbits)
					period, // number - orbital period (for planet orbits)
					angle, // number - starting angle (for planet orbits)
					transitionProgress = 0, // number - transition progress (0-1)
					segments = 100, // number - number of segments for the path
					strokeWidth = 1, // number - orbit stroke width
					alpha = 0.2, // number - orbit opacity
					group, // paper.Group - group to add orbit to
				} = config;

				const orbitRadiusOnScreen = distance * simulationState.scale;

				// Hide orbits larger than the screen
				const maxVisibleRadius =
					Math.min(paper.view.size.width, paper.view.size.height) / 2;
				if (orbitRadiusOnScreen > maxVisibleRadius) {
					return;
				}

				const orbitPath = new paper.Path();
				const orbitColor = new paper.Color(color);
				orbitColor.alpha = alpha;
				orbitPath.strokeColor = orbitColor;
				orbitPath.strokeWidth = strokeWidth;

				// Calculate orbit center offset during transition (for planet orbits)
				let orbitCenterOffset = new paper.Point(0, 0);
				if (
					transitionProgress > 0 &&
					time !== undefined &&
					period !== undefined &&
					angle !== undefined
				) {
					// Calculate where the body currently is in its orbit
					const currentAngle = angle + (time / period) * Math.PI * 2;
					const x = Math.cos(currentAngle) * distance * simulationState.scale;
					const z = Math.sin(currentAngle) * distance * simulationState.scale;
					const incRad = (orbitalInclination * Math.PI) / 180;
					const y = z * Math.sin(incRad);
					const zInclined = z * Math.cos(incRad);
					const currentBodyPos = project3DTo2D(
						x,
						y,
						zInclined,
						simulationState.inclination,
						simulationState.rotation,
					);

					// Offset orbit so body position moves toward center
					orbitCenterOffset = currentBodyPos.multiply(-transitionProgress);
				}

				// Draw orbit segments
				for (let i = 0; i <= segments; i++) {
					const orbitAngle = (i / segments) * Math.PI * 2;
					const x = Math.cos(orbitAngle) * distance * simulationState.scale;
					const z = Math.sin(orbitAngle) * distance * simulationState.scale;

					// Apply orbital simulationState.inclination (rotate around x-axis)
					const incRad = (orbitalInclination * Math.PI) / 180;
					const y = z * Math.sin(incRad);
					const zInclined = z * Math.cos(incRad);

					const screenPos = project3DTo2D(
						x,
						y,
						zInclined,
						simulationState.inclination,
						simulationState.rotation,
					);
					orbitPath.add(centerPosition.add(screenPos).add(orbitCenterOffset));
				}

				orbitPath.closed = true;
				group.addChild(orbitPath);
			}

			// Draw a celestial body (planet or moon) with click area and optional label
			function drawCelestialBody(config) {
				const {
					position, // paper.Point - screen position
					size, // number - actual size in pixels
					color, // string - fill color
					name, // string - display name
					bodyType, // string - "planet" or "moon"
					bodyIndex, // number - planet index (for planets)
					moonName, // string - moon name (for moons)
					orbitRadius, // number - orbit radius on screen (for label visibility check)
					opacity = 1, // number - opacity (for fade effects)
					showLabel = true, // boolean - whether to show label
					labelSuffix = "", // string - suffix for label (e.g., "(-10x)")
					strokeWidth = 0.5, // number - border stroke width
				} = config;

				// Draw the body
				const bodyCircle = new paper.Path.Circle(position, size);
				bodyCircle.fillColor = color;
				bodyCircle.strokeColor = "white";
				bodyCircle.strokeWidth = strokeWidth;
				bodyCircle.opacity = opacity;
				bodyCircle.data = {
					type: bodyType,
					planetIndex: bodyIndex,
					moonName: moonName,
					isBody: true,
				};

				if (bodyType === "planet") {
					planetGroup.addChild(bodyCircle);
				} else {
					moonGroup.addChild(bodyCircle);
				}

				// Add clickable circle around body
				// Make it 20px larger than body, or minimum 20px radius (40px diameter)
				const baseClickRadius = Math.max(size + 10, 20);

				// Check if this body is currently hovered/animating
				const hoverState = bodyHoverStates.get(name);
				let clickRadius = baseClickRadius;
				if (hoverState) {
					// Use the animated radius from hover state
					clickRadius = hoverState.radius;
				}

				const clickCircle = new paper.Path.Circle(position, clickRadius);
				clickCircle.strokeColor = null; // Hide stroke
				// Use transparent fill with alpha 0.01 for hover detection
				clickCircle.fillColor = new paper.Color(1, 1, 1, 0.01);
				clickCircle.opacity = opacity;
				clickCircle.data = {
					type: bodyType,
					planetIndex: bodyIndex,
					moonName: moonName,
					bodyName: name,
					isClickArea: true,
					originalRadius: baseClickRadius,
					orbitRadius: orbitRadius, // Store orbit radius to check label visibility
				};
				clickAreaGroup.addChild(clickCircle);

				// Draw composition diagram if hover state indicates it should be shown
				if (hoverState && hoverState.showComposition) {
					drawCompositionDiagram(clickCircle, name);
				}

				// Draw label if enabled and orbit is large enough
				if (showLabel && orbitRadius >= minOrbitRadiusForLabel) {
					const targetGroup = bodyType === "planet" ? labelGroup : moonGroup;

					// Check if this body is currently hovered/animating
					const hoverState = bodyHoverStates.get(name);
					let currentLabelRadius = clickRadius;

					if (hoverState) {
						// Use the animated radius from hover state
						currentLabelRadius = hoverState.radius;
					}

					// Hide label if another body is being hovered
					const isAnyBodyHovered = bodyHoverStates.size > 0;
					const isThisBodyHovered = hoverState !== undefined;
					const shouldHideLabel = isAnyBodyHovered && !isThisBodyHovered;

					// Get current layer for this body
					const currentLayer = hoverState?.currentLayer || "surface";

					if (!shouldHideLabel) {
						drawLabel({
							position: position,
							startRadius: currentLabelRadius,
							name: name,
							labelSuffix: labelSuffix,
							bodyType: bodyType,
							opacity: opacity,
							targetGroup: targetGroup,
							currentLayer: isThisBodyHovered ? currentLayer : null, // Only show when hovered
						});
					}
				}
			}

			// Update planet positions
			function updatePlanets() {
				planetGroup.removeChildren();
				labelGroup.removeChildren();
				moonGroup.removeChildren();
				clickAreaGroup.removeChildren();

				if (simulationState.viewMode === "solar-system") {
					// Redraw sun
					const sun = drawSun();
					sun.opacity = fadeOpacity;
					planetGroup.addChild(sun);
				}

				planetsData.forEach((planet, planetIndex) => {
					// Calculate orbital position using unified function
					const orbitalData = calculateOrbitalPosition({
						time: time,
						period: planet.period,
						angle: planet.angle,
						distance: planet.distance,
						scale: simulationState.scale,
						orbitalInclination: planet.orbitalInclination,
						inclination: simulationState.inclination,
					});

					let planetPos = center.add(orbitalData.screenPos);

					// Calculate orbit radius on screen
					const orbitRadiusOnScreen = orbitalData.scaledDistance;

					// Store selected planet's initial position
					if (
						selectedPlanet === planet &&
						transitionProgress === 0 &&
						simulationState.viewMode !== "planet-moons"
					) {
						selectedPlanetPosition = planetPos.clone();
					}

					// Apply planet offset with transition animation
					if (
						selectedPlanet === planet &&
						(simulationState.viewMode === "planet-moons" ||
							transitionProgress > 0)
					) {
						// Interpolate position from original to center
						const startPos = selectedPlanetPosition || planetPos;
						planetPos = startPos
							.multiply(1 - transitionProgress)
							.add(center.multiply(transitionProgress));
					} else if (
						simulationState.viewMode === "planet-moons" &&
						selectedPlanet !== planet
					) {
						// Skip rendering other planets in moon view
						return;
					}

					// Draw planet with scaled size (scales down with zoom out, but has minimum)
					const minSize = 2; // Minimum planet size in pixels
					let effectiveSize = planet.size;

					// Calculate target size for moon view
					const targetSize = planet.size > 5 ? planet.size / 10 : planet.size;

					// Interpolate size during transition if this is the selected planet
					if (
						selectedPlanet === planet &&
						transitionProgress > 0 &&
						transitionProgress < 1
					) {
						effectiveSize =
							planet.size * (1 - transitionProgress) +
							targetSize * transitionProgress;
					} else if (
						simulationState.viewMode === "planet-moons" &&
						selectedPlanet === planet &&
						planet.size > 5
					) {
						effectiveSize = planet.size / 10;
					}

					const scaledSize = Math.max(
						effectiveSize * simulationState.scale,
						minSize,
					);

					// Determine label suffix
					const labelSuffix =
						simulationState.viewMode === "planet-moons" &&
						selectedPlanet === planet &&
						planet.size > 5
							? " (-10x)"
							: "";

					// Calculate opacity
					const planetOpacity =
						selectedPlanet && selectedPlanet !== planet ? fadeOpacity : 1;

					// Draw the planet using the unified function
					drawCelestialBody({
						position: planetPos,
						size: scaledSize,
						color: planet.color,
						name: planet.name,
						bodyType: "planet",
						bodyIndex: planetIndex,
						orbitRadius: orbitRadiusOnScreen,
						opacity: planetOpacity,
						showLabel: simulationState.showLabels,
						labelSuffix: labelSuffix,
						strokeWidth: 0.5,
					});
				});

				// Render moons if in moon view mode
				if (simulationState.viewMode === "planet-moons" && selectedPlanet) {
					renderMoons(selectedPlanet, center);
				}
			}

			// Render moons around a planet
			function renderMoons(planet, planetPos) {
				if (!planet.moons || planet.moons.length === 0) return;

				planet.moons.forEach((moon) => {
					// Calculate orbital position using unified function
					const orbitalData = calculateOrbitalPosition({
						time: time,
						period: moon.period,
						angle: moon.angle,
						distance: moon.distance,
						scale: simulationState.scale,
						orbitalInclination: moon.orbitalInclination,
						inclination: simulationState.inclination,
					});

					const moonPos = planetPos.add(orbitalData.screenPos);

					// Calculate orbit radius on screen for this moon
					const moonOrbitRadiusOnScreen = orbitalData.scaledDistance;

					// Draw moon orbit using unified function
					if (simulationState.showOrbits) {
						drawOrbitPath({
							centerPosition: planetPos,
							distance: moon.distance,
							scale: simulationState.scale,
							color: moon.color,
							orbitalInclination: moon.orbitalInclination,
							inclination: simulationState.inclination,
							segments: 50,
							strokeWidth: 0.5,
							alpha: 0.4,
							group: moonGroup,
						});
					}

					// Draw moon with scaled size (with minimum)
					const minMoonSize = 1.5;
					const scaledMoonSize = Math.max(
						moon.size * simulationState.scale,
						minMoonSize,
					);

					// Draw the moon using the unified function
					drawCelestialBody({
						position: moonPos,
						size: scaledMoonSize,
						color: moon.color,
						name: moon.name,
						bodyType: "moon",
						moonName: moon.name,
						orbitRadius: moonOrbitRadiusOnScreen,
						opacity: 1,
						showLabel: simulationState.showLabels,
						labelSuffix: "",
						strokeWidth: 0.3,
					});
				});
			}

			// Animation loop
			function animate() {
				// Pause rotation when hovering over any celestial body
				const isHovering = hoveredClickArea !== null;

				if (!simulationState.isPaused && !isHovering) {
					time += simulationState.timeSpeed * 0.5;
					updatePlanets();
				} else if (isHovering || bodyHoverStates.size > 0) {
					// Update when hovering or when there are active hover animations
					updatePlanets();
				}
			}

			// Initialize
			function init() {
				time = 0;
				drawAxisLines();
				drawOrbits();
				updatePlanets();
				controlsInstance.updateScaleIndicators();
			}

			// Set up animation frame
			paper.view.onFrame = function (event) {
				animate();
			};

			// Initialize SVG export with 'd' key
			SvgExport.initSvgExport(paper.project);

			// Initialize Controls with shared state object
			const controlsInstance = new Controls({
				state: simulationState, // Pass the object reference, not copies
				callbacks: {
					drawOrbits,
					updatePlanets,
					transitionToSolarSystem,
				},
			});

			// Animate radius change with smooth transition (state-based)
			function animateRadius(circle, targetRadius, duration = 500) {
				const bodyName = circle.data.bodyName;
				if (!bodyName) return;

				const originalRadius = circle.data.originalRadius;
				const startRadius = circle.bounds.width / 2;

				// Cancel any existing animation for this body
				const existingState = bodyHoverStates.get(bodyName);
				if (existingState && existingState.animationId) {
					cancelAnimationFrame(existingState.animationId);
				}

				const startTime = Date.now();
				const isExpanding = targetRadius > originalRadius;

				function step() {
					const elapsed = Date.now() - startTime;
					const progress = Math.min(elapsed / duration, 1);

					// Ease out cubic for smooth deceleration
					const eased = 1 - Math.pow(1 - progress, 3);
					const currentRadius =
						startRadius + (targetRadius - startRadius) * eased;

					// Update global hover state (preserve existing properties)
					if (bodyName) {
						const isExpanding = targetRadius > originalRadius;
						const existingState = bodyHoverStates.get(bodyName) || {};
						bodyHoverStates.set(bodyName, {
							...existingState, // Preserve existing properties like compositionAnimStarted
							progress: isExpanding ? eased : 1 - eased,
							radius: currentRadius,
							originalRadius: originalRadius,
							currentLayer: existingState.currentLayer || "surface", // Default to surface layer
						});
					}

					if (progress < 1) {
						bodyHoverStates.get(bodyName).animationId =
							requestAnimationFrame(step);
					} else {
						// Animation complete
						if (isExpanding) {
							// Mark that composition should be shown
							const currentState = bodyHoverStates.get(bodyName);
							if (currentState) {
								currentState.showComposition = true;
								currentState.animationId = null;
							}
						} else {
							// Clean up hover state if contracting back to original
							bodyHoverStates.delete(bodyName);
							// Force one final redraw to restore all labels
							updatePlanets();
						}
					}
				}

				step();
			}

			// Draw composition pie chart around click circle
			function drawCompositionDiagram(clickCircle, bodyName) {
				// Find celestial body data
				const planetData = celestialBodyCompositions.find(
					(p) => p.name === bodyName,
				);
				if (!planetData) {
					return; // Don't draw if no data
				}

				// Get current layer from hover state
				const hoverState = bodyHoverStates.get(bodyName);
				const currentLayer = hoverState?.currentLayer || "surface";

				// Get the layer composition
				const layerData = planetData.layers[currentLayer];
				if (!layerData || layerData.length === 0) return;

				// Calculate radius - 5px outside the click circle
				const centerPos = clickCircle.position;
				const innerRadius = clickCircle.bounds.width / 2;
				const strokeWidth = 5;

				// Calculate segment boundaries for colors
				let currentAngle = -Math.PI / 2; // Start at top (12 o'clock)
				const segments = [];

				layerData.forEach((compound) => {
					const color = getFormulaColor(compound.formula);
					const arcAngle = (compound.percent / 100) * Math.PI * 2;

					segments.push({
						startAngle: currentAngle,
						endAngle: currentAngle + arcAngle,
						color: color,
					});

					currentAngle += arcAngle;
				});

				// Get or start animation progress
				// (hoverState already declared above when getting currentLayer)
				let drawProgress = 1.0; // Default to full circle

				if (hoverState) {
					if (hoverState.compositionAnimProgress !== undefined) {
						// Animation in progress or complete
						drawProgress = hoverState.compositionAnimProgress;
					} else if (!hoverState.compositionAnimStarted) {
						// Start the composition animation only once
						hoverState.compositionAnimStarted = true;
						hoverState.compositionAnimProgress = 0;
						startCompositionAnimation(bodyName);
						drawProgress = 0;
					}
				}

				const startAngle = -Math.PI / 2; // 12 o'clock
				const endAngle = startAngle + Math.PI * 2; // Full circle
				const currentDrawAngle =
					startAngle + (endAngle - startAngle) * drawProgress;

				// Draw each color segment up to current angle
				segments.forEach((seg) => {
					if (currentDrawAngle > seg.startAngle) {
						const segStartAngle = seg.startAngle;
						const segEndAngle = Math.min(seg.endAngle, currentDrawAngle);

						// Create path for this colored segment
						const segPath = new paper.Path();
						segPath.strokeColor = seg.color;
						segPath.strokeWidth = strokeWidth;
						segPath.strokeCap = "round";

						const segSteps = 30;
						for (let i = 0; i <= segSteps; i++) {
							const angle =
								segStartAngle + ((segEndAngle - segStartAngle) * i) / segSteps;
							const x = centerPos.x + Math.cos(angle) * innerRadius;
							const y = centerPos.y + Math.sin(angle) * innerRadius;
							segPath.add(new paper.Point(x, y));
						}

						clickAreaGroup.addChild(segPath);
					}
				});

				// Draw formula labels around the circle if animation is complete or near complete
				if (drawProgress > 0.8) {
					segments.forEach((seg) => {
						// Only draw labels for segments that have been drawn
						if (currentDrawAngle > seg.startAngle) {
							// Calculate middle angle of this segment
							const segMidAngle = (seg.startAngle + seg.endAngle) / 2;

							// Position label outside the circle (15px beyond the click circle)
							const labelRadius =
								innerRadius + simulationState.labelFontSize + 5;
							const labelX = centerPos.x + Math.cos(segMidAngle) * labelRadius;
							const labelY = centerPos.y + Math.sin(segMidAngle) * labelRadius;

							// Find the compound data for this segment
							const segmentIndex = segments.indexOf(seg);
							const compound = layerData[segmentIndex];

							if (compound && (compound.formula || compound.compound)) {
								const formulaLabel = new paper.PointText(
									new paper.Point(labelX, labelY),
								);
								// Use compound name if option is enabled, otherwise use formula
								formulaLabel.content = simulationState.showCompoundNames
									? compound.compound
									: formatFormulaWithSubscripts(compound.formula);
								formulaLabel.fillColor = seg.color;
								formulaLabel.fontSize = simulationState.labelFontSize * 0.8;
								formulaLabel.fontFamily = "monospace";
								formulaLabel.justification = "center";
								formulaLabel.opacity = Math.min(drawProgress, 1);

								// Add slight background for readability
								const labelBounds = formulaLabel.bounds;
								const background = new paper.Path.Rectangle(
									labelBounds.expand(2),
								);
								background.fillColor = new paper.Color(0, 0, 0, 0.5);
								clickAreaGroup.addChild(background);
								clickAreaGroup.addChild(formulaLabel);
							}
						}
					});
				}
			}

			// Start composition animation for a body
			function startCompositionAnimation(bodyName) {
				const animDuration = 1000;
				const startTime = Date.now();

				function animateStep() {
					const elapsed = Date.now() - startTime;
					const progress = Math.min(elapsed / animDuration, 1);

					// Ease out cubic
					const eased = 1 - Math.pow(1 - progress, 3);

					const hoverState = bodyHoverStates.get(bodyName);
					if (hoverState) {
						hoverState.compositionAnimProgress = eased;
					}

					if (progress < 1) {
						requestAnimationFrame(animateStep);
					}
				}

				animateStep();
			}

			// Snap angle to nearest snap point
			function snapAngle(angle, snapPoints, threshold = 2) {
				for (let snapPoint of snapPoints) {
					if (Math.abs(angle - snapPoint) <= threshold) {
						return snapPoint;
					}
				}
				return angle;
			}

			// Snap points for simulationState.inclination and simulationState.rotation
			const inclinationSnapPoints = [-60, -45, -30, 0, 30, 45, 60];
			const rotationSnapPoints = [0, 45, 90, 135, 180, 225, 270, 315];

			// Get canvas element for drag controls
			const canvas = document.getElementById("myCanvas");

			// Drag to change simulationState.inclination and simulationState.rotation, and click detection
			let isDragging = false;
			let dragStartX = 0;
			let dragStartY = 0;
			let dragStartInclination = 0;
			let dragStartRotation = 0;
			let dragMoved = false;
			let hoveredClickArea = null;
			let hoverAnimationFrame = null;

			// Global hover state tracking - stores hover animation progress for each body
			const bodyHoverStates = new Map(); // bodyName -> { progress: 0-1, radius: number }

			canvas.addEventListener("mousedown", (event) => {
				isDragging = true;
				dragStartX = event.clientX;
				dragStartY = event.clientY;
				dragStartInclination = simulationState.inclination;
				dragStartRotation = simulationState.rotation;
				dragMoved = false;
			});

			canvas.addEventListener("mousemove", (event) => {
				const rect = canvas.getBoundingClientRect();
				const x = event.clientX - rect.left;
				const y = event.clientY - rect.top;
				const mousePoint = new paper.Point(x, y);

				// Check for hover over click areas or celestial bodies
				const hitResult = paper.project.hitTest(mousePoint, {
					fill: true,
					stroke: true,
					tolerance: 5,
				});

				let foundClickArea = null;

				// If we hit something, find the associated click area
				if (hitResult && hitResult.item) {
					if (hitResult.item.data?.isClickArea) {
						// Directly hit the click area
						foundClickArea = hitResult.item;
					} else if (hitResult.item.data?.isBody) {
						// Hit a celestial body, find its click area by searching for matching one
						const bodyType = hitResult.item.data.type;

						// Search through click area group for matching body
						clickAreaGroup.children.forEach((child) => {
							if (child.data?.isClickArea && child.data?.type === bodyType) {
								// Check if positions match (within tolerance)
								const distance = child.position.getDistance(
									hitResult.item.position,
								);
								if (distance < 5) {
									foundClickArea = child;
								}
							}
						});
					}
				}

				// Reset previous hover state with animation
				if (hoveredClickArea && hoveredClickArea !== foundClickArea) {
					if (hoveredClickArea.data?.originalRadius) {
						// Animate back to original size
						animateRadius(
							hoveredClickArea,
							hoveredClickArea.data.originalRadius,
						);
					}
					hoveredClickArea = null;
				}

				// Apply hover effect to new item with animation
				if (foundClickArea && foundClickArea !== hoveredClickArea) {
					// Only animate if label is visible
					const orbitRadius = foundClickArea.data.orbitRadius || 0;
					const hasVisibleLabel = orbitRadius >= minOrbitRadiusForLabel;

					if (hasVisibleLabel) {
						// Store original radius if not already stored
						if (!foundClickArea.data.originalRadius) {
							foundClickArea.data.originalRadius =
								foundClickArea.bounds.width / 2;
						}

						hoveredClickArea = foundClickArea;

						// Animate to 200% size (100% larger)
						const targetRadius = foundClickArea.data.originalRadius * 2;
						animateRadius(foundClickArea, targetRadius);

						canvas.style.cursor = "pointer";
					}
				} else if (!foundClickArea) {
					canvas.style.cursor = isDragging ? "grabbing" : "grab";
				}

				if (!isDragging) return;

				// Calculate simulationState.inclination and simulationState.rotation changes based on mouse movement
				const deltaX = event.clientX - dragStartX;
				const deltaY = event.clientY - dragStartY;

				// Mark as dragged if moved more than 5 pixels
				if (Math.abs(deltaY) > 5 || Math.abs(deltaX) > 5) {
					dragMoved = true;
				}

				// Vertical drag: adjust inclination (-90 to 90 degrees)
				const inclinationChange = deltaY * 0.2; // Sensitivity factor (positive = drag down increases)
				let newInclination = Math.max(
					-90,
					Math.min(90, dragStartInclination + inclinationChange),
				);
				// Apply snapping (this updates simulationState directly)
				simulationState.inclination = snapAngle(
					newInclination,
					inclinationSnapPoints,
				);

				// Horizontal drag: adjust rotation (0 to 360 degrees, wrapping)
				const rotationChange = -deltaX * 0.2; // Sensitivity factor (negative = drag right rotates clockwise)
				let newRotation = (dragStartRotation + rotationChange + 360) % 360;
				// Apply snapping (handle wraparound at 360/0)
				simulationState.rotation = snapAngle(newRotation, rotationSnapPoints);
				// Also check snap to 360 (same as 0)
				if (Math.abs(newRotation - 360) <= 5) {
					simulationState.rotation = 0;
				}

				// Update display
				controlsInstance.updateDisplays();

				drawAxisLines();
				drawOrbits();
				updatePlanets();
			});

			canvas.addEventListener("mouseup", (event) => {
				if (!dragMoved && isDragging) {
					// This was a click, not a drag - check for planet click
					handleCanvasClick(event);
				}
				isDragging = false;
			});

			canvas.addEventListener("mouseleave", () => {
				isDragging = false;
			});

			// Handle canvas click for planet selection
			function handleCanvasClick(event) {
				const rect = canvas.getBoundingClientRect();
				const x = event.clientX - rect.left;
				const y = event.clientY - rect.top;
				const clickPoint = new paper.Point(x, y);

				// Hit test to find clicked planet or click area
				const hitResult = paper.project.hitTest(clickPoint, {
					fill: true,
					stroke: true,
					tolerance: 5,
				});

				if (
					hitResult &&
					hitResult.item.data &&
					["planet", "moon"].includes(hitResult.item.data.type)
				) {
					const bodyType = hitResult.item.data.type;
					const bodyName = hitResult.item.data.bodyName;

					// Check if this celestial body is currently hovered (has composition showing)
					const hoverState = bodyHoverStates.get(bodyName);
					if (hoverState && hoverState.showComposition) {
						// Cycle to next layer for both planets and moons
						cycleLayer(bodyName);
					} else if (
						bodyType === "planet" &&
						simulationState.viewMode === "solar-system"
					) {
						// Select planet and transition to moon view (only for planets in solar system view)
						const planetIndex = hitResult.item.data.planetIndex;
						const planet = planetsData[planetIndex];
						selectedPlanet = planet;
						transitionToPlanetView();
					}
				} else if (simulationState.viewMode === "planet-moons") {
					// Click on empty space in moon view - return to solar system
					transitionToSolarSystem();
				}
			}

			// Cycle through available layers for a celestial body
			function cycleLayer(bodyName) {
				const hoverState = bodyHoverStates.get(bodyName);
				if (!hoverState) return;

				// Get celestial body composition data to find available layers
				const planetData = celestialBodyCompositions.find(
					(p) => p.name === bodyName,
				);
				if (!planetData) return;

				const availableLayers = Object.keys(planetData.layers);
				const currentLayer = hoverState.currentLayer || "surface";
				const currentIndex = availableLayers.indexOf(currentLayer);
				const nextIndex = (currentIndex + 1) % availableLayers.length;
				const nextLayer = availableLayers[nextIndex];

				// Update layer and reset composition animation
				hoverState.currentLayer = nextLayer;
				hoverState.compositionAnimStarted = false;
				hoverState.compositionAnimProgress = undefined;
				delete hoverState.showComposition;

				// Trigger re-expansion to restart composition animation
				hoverState.showComposition = true;

				// Force redraw
				updatePlanets();
			}

			// Transition to planet view (with fade animation)
			function transitionToPlanetView() {
				// Animate fade out and planet movement
				const fadeSteps = 25;
				const stepDuration = 20; // 20ms per step = 500ms total
				let step = 0;
				const fadeInterval = setInterval(() => {
					step++;
					const progress = step / fadeSteps;
					fadeOpacity = 1 - progress;
					transitionProgress = progress;
					drawOrbits();
					updatePlanets();

					if (step >= fadeSteps) {
						clearInterval(fadeInterval);
						fadeOpacity = 0;
						transitionProgress = 1;
						// Switch to moon view AFTER fade completes
						simulationState.viewMode = "planet-moons";
						drawOrbits();
						updatePlanets();
					}
				}, stepDuration);
			}

			// Transition back to solar system view
			function transitionToSolarSystem() {
				// Switch to solar system view immediately
				simulationState.viewMode = "solar-system";
				selectedPlanet = null;
				selectedPlanetPosition = null;

				// Animate fade in
				const fadeSteps = 25;
				const stepDuration = 20; // 20ms per step = 500ms total
				let step = 0;
				const fadeInterval = setInterval(() => {
					step++;
					const progress = step / fadeSteps;
					fadeOpacity = progress;
					transitionProgress = 1 - progress; // Reverse transition
					drawOrbits();
					updatePlanets();

					if (step >= fadeSteps) {
						clearInterval(fadeInterval);
						fadeOpacity = 1.0;
						transitionProgress = 0;
					}
				}, stepDuration);
			}

			// Start the simulation
			init();
		</script>
	</body>
</html>
